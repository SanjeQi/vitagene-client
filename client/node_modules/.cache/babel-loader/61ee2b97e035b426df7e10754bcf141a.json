{"ast":null,"code":"var fs = require('fs'),\n    mm = require('minimatch'),\n    path = require('path');\n/**\n * merge two objects by extending target object with source object\n * @param target object to merge\n * @param source object to merge\n * @param {Boolean} [modify] whether to modify the target\n * @returns {Object} extended object\n */\n\n\nfunction extend(target, source, modify) {\n  var result = target ? modify ? target : extend({}, target, true) : {};\n  if (!source) return result;\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key) && source[key] !== undefined) {\n      result[key] = source[key];\n    }\n  }\n\n  return result;\n}\n/**\n * determine if a string is contained within an array or matches a regular expression\n * @param   {String} str string to match\n * @param   {Array|Regex} match array or regular expression to match against\n * @returns {Boolean} whether there is a match\n */\n\n\nfunction matches(str, match) {\n  if (Array.isArray(match)) {\n    var l = match.length;\n\n    for (var s = 0; s < l; s++) {\n      if (mm(str, match[s])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return match.test(str);\n}\n/**\n * read files and call a function with the contents of each file\n * @param  {String} dir path of dir containing the files to be read\n * @param  {String} encoding file encoding (default is 'utf8')\n * @param  {Object} options options hash for encoding, recursive, and match/exclude\n * @param  {Function(error, string)} callback  callback for each files content\n * @param  {Function(error)}   complete  fn to call when finished\n */\n\n\nfunction readFilesStream(dir, options, callback, complete) {\n  if (typeof options === 'function') {\n    complete = callback;\n    callback = options;\n    options = {};\n  }\n\n  if (typeof options === 'string') options = {\n    encoding: options\n  };\n  options = extend({\n    recursive: true,\n    encoding: 'utf8',\n    doneOnErr: true\n  }, options);\n  var files = [];\n\n  var done = function done(err) {\n    if (typeof complete === 'function') {\n      if (err) return complete(err);\n      complete(null, files);\n    }\n  };\n\n  fs.readdir(dir, function (err, list) {\n    if (err) {\n      if (options.doneOnErr === true) {\n        if (err.code === 'EACCES') return done();\n        return done(err);\n      }\n    }\n\n    var i = 0;\n\n    if (options.reverse === true || typeof options.sort == 'string' && /reverse|desc/i.test(options.sort)) {\n      list = list.reverse();\n    } else if (options.sort !== false) list = list.sort();\n\n    (function next() {\n      var filename = list[i++];\n      if (!filename) return done(null, files);\n      var file = path.join(dir, filename);\n      fs.stat(file, function (err, stat) {\n        if (err && options.doneOnErr === true) return done(err);\n\n        if (stat && stat.isDirectory()) {\n          if (options.recursive) {\n            if (options.matchDir && !matches(filename, options.matchDir)) return next();\n            if (options.excludeDir && matches(filename, options.excludeDir)) return next();\n            readFilesStream(file, options, callback, function (err, sfiles) {\n              if (err && options.doneOnErr === true) return done(err);\n              files = files.concat(sfiles);\n              next();\n            });\n          } else next();\n        } else if (stat && stat.isFile()) {\n          if (options.match && !matches(filename, options.match)) return next();\n          if (options.exclude && matches(filename, options.exclude)) return next();\n          if (options.filter && !options.filter(filename)) return next();\n          if (options.shortName) files.push(filename);else files.push(file);\n          var stream = fs.createReadStream(file);\n\n          if (options.encoding !== null) {\n            stream.setEncoding(options.encoding);\n          }\n\n          stream.on('error', function (err) {\n            if (options.doneOnErr === true) return done(err);\n            next();\n          });\n          if (callback.length > 3) {\n            if (options.shortName) callback(null, stream, filename, next);else callback(null, stream, file, next);\n          } else callback(null, stream, next);\n        } else {\n          next();\n        }\n      });\n    })();\n  });\n}\n\nmodule.exports = readFilesStream;","map":null,"metadata":{},"sourceType":"script"}