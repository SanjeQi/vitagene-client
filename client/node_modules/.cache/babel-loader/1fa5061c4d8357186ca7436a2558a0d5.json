{"ast":null,"code":"var fs = require('fs'),\n    path = require('path');\n\nexports.promiseFiles = function promiseFiles(dir, type, options) {\n  type = type || 'file';\n\n  var processor = function processor(res, rej) {\n    var cb = function cb(err, data) {\n      if (err) return rej(err);\n      res(data);\n    };\n\n    exports.files(dir, type, cb, options);\n  };\n\n  return new Promise(processor);\n};\n/**\n * find all files or subdirs (recursive) and pass to callback fn\n *\n * @param {string} dir directory in which to recurse files or subdirs\n * @param {string} type type of dir entry to recurse ('file', 'dir', or 'all', defaults to 'file')\n * @param {function(error, <Array.<string>)} callback fn to call when done\n * @example\n * dir.files(__dirname, function(err, files) {\n *      if (err) throw err;\n *      console.log('files:', files);\n *  });\n */\n\n\nexports.files = function files(dir, type, callback, options) {\n  var ofType = typeof type;\n\n  if (ofType == 'object') {\n    options = options || type;\n    type = 'file';\n\n    callback = function callback() {};\n  } else if (ofType !== 'string') {\n    //ignoreType = callback;\n    callback = type;\n    type = 'file';\n  }\n\n  options = options || {};\n  var pending,\n      results = {\n    files: [],\n    dirs: []\n  };\n\n  var done = function done() {\n    if (type === 'combine') {\n      results = results.files.concat(results.dirs);\n    } else if (!type || options.ignoreType || ['all', 'combine'].indexOf(type) >= 0) {\n      results = results;\n    } else {\n      results = results[type + 's'];\n    }\n\n    if (options.sync) return;\n    callback(null, results);\n  };\n\n  var getStatHandler = function getStatHandler(statPath, name, lstatCalled) {\n    return function (err, stat) {\n      if (err) {\n        if (!lstatCalled) {\n          return fs.lstat(statPath, getStatHandler(statPath, name, true));\n        }\n\n        return callback(err);\n      }\n\n      var pushVal = options.shortName ? name : statPath;\n\n      if (stat && stat.isDirectory() && stat.mode !== 17115) {\n        if (type !== 'file') {\n          results.dirs.push(pushVal);\n        }\n\n        if (options.recursive == null || options.recursive) {\n          var subloop = function subloop(err, res) {\n            if (err) {\n              return callback(err);\n            }\n\n            if (type === 'combine') {\n              results.files = results.files.concat(res);\n            } else if (type === 'all') {\n              results.files = results.files.concat(res.files);\n              results.dirs = results.dirs.concat(res.dirs);\n            } else if (type === 'file') {\n              results.files = results.files.concat(res.files);\n            } else {\n              results.dirs = results.dirs.concat(res.dirs);\n            }\n\n            if (! --pending) {\n              done();\n            }\n          };\n\n          var newOptions = Object.assign({}, options);\n          newOptions.ignoreType = true;\n          var moreResults = files(statPath, type, subloop, newOptions);\n\n          if (options.sync) {\n            subloop(null, moreResults);\n          }\n        } else if (! --pending) {\n          done();\n        }\n      } else {\n        if (type !== 'dir') {\n          results.files.push(pushVal);\n        } // should be the last statement in statHandler\n\n\n        if (! --pending) {\n          done();\n        }\n      }\n    };\n  };\n\n  var bufdir = Buffer.from(dir);\n\n  var onDirRead = function onDirRead(err, list) {\n    if (err) return callback(err);\n    pending = list.length;\n    if (!pending) return done();\n\n    for (var file, i = 0, l = list.length; i < l; i++) {\n      var fname = list[i].toString();\n      file = path.join(dir, fname);\n      var buffile = Buffer.concat([bufdir, Buffer.from(path.sep), list[i]]);\n\n      if (options.sync) {\n        var res = fs.statSync(buffile);\n        getStatHandler(file, fname)(null, res);\n      } else {\n        fs.stat(buffile, getStatHandler(file, fname));\n      }\n    }\n\n    return results;\n  };\n\n  var onStat = function onStat(err, stat) {\n    if (err) return callback(err);\n    if (stat && stat.mode === 17115) return done();\n\n    if (options.sync) {\n      var list = fs.readdirSync(bufdir, {\n        encoding: 'buffer'\n      });\n      return onDirRead(null, list);\n    } else {\n      fs.readdir(bufdir, {\n        encoding: 'buffer'\n      }, onDirRead);\n    }\n  };\n\n  if (options.sync) {\n    var stat = fs.statSync(bufdir);\n    return onStat(null, stat);\n  } else {\n    fs.stat(bufdir, onStat);\n  }\n};\n/**\n * find all files and subdirs in  a directory (recursive) and pass them to callback fn\n *\n * @param {string} dir directory in which to recurse files or subdirs\n * @param {boolean} combine whether to combine both subdirs and filepaths into one array (default false)\n * @param {function(error, Object.<<Array.<string>, Array.<string>>)} callback fn to call when done\n * @example\n * dir.paths(__dirname, function (err, paths) {\n *     if (err) throw err;\n *     console.log('files:', paths.files);\n *     console.log('subdirs:', paths.dirs);\n * });\n * dir.paths(__dirname, true, function (err, paths) {\n *      if (err) throw err;\n *      console.log('paths:', paths);\n * });\n */\n\n\nexports.paths = function paths(dir, combine, callback) {\n  var type;\n\n  if (typeof combine === 'function') {\n    callback = combine;\n    combine = false;\n  }\n\n  exports.files(dir, 'all', function (err, results) {\n    if (err) return callback(err);\n\n    if (combine) {\n      callback(null, results.files.concat(results.dirs));\n    } else {\n      callback(null, results);\n    }\n  });\n};\n/**\n * find all subdirs (recursive) of a directory and pass them to callback fn\n *\n * @param {string} dir directory in which to find subdirs\n * @param {string} type type of dir entry to recurse ('file' or 'dir', defaults to 'file')\n * @param {function(error, <Array.<string>)} callback fn to call when done\n * @example\n * dir.subdirs(__dirname, function (err, paths) {\n *      if (err) throw err;\n *      console.log('files:', paths.files);\n *      console.log('subdirs:', paths.dirs);\n * });\n */\n\n\nexports.subdirs = function subdirs(dir, callback, type, options) {\n  options = options || {};\n\n  var iCallback = function iCallback(err, subdirs) {\n    if (err) return callback(err);\n\n    if (type == 'combine') {\n      subdirs = subdirs.files.concat(subdirs.dirs);\n    }\n\n    if (options.sync) return subdirs;\n    callback(null, subdirs);\n  };\n\n  var res = exports.files(dir, 'dir', iCallback, options);\n\n  if (options && options.sync) {\n    return iCallback(null, res);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}